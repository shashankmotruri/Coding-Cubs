{% extends "pages/learn.html" %}
{% load static %}
{% block nav-bellman_ford %}

<div>
    <div class="content-div">
        <ul class="nav nav-tabs">
            <li class="active"><a data-toggle="tab" href="#description">Description</a></li>
            <li><a data-toggle="tab" href="#sources">Sources</a></li>
        </ul>

        <div class="tab-content ">
            <div id="description" class="tab-pane fade in active">
                <h3><strong>Bellman Ford : </strong></h3>
                <p>Bellman Ford's algorithm is used to find the shortest paths from the source vertex to all other vertices in a weighted graph. It depends on the following concept: Shortest path contains at most $$n-1$$ edges, because the shortest path couldn't have a cycle.  </p>
                <p>So why shortest path shouldn't have a cycle ?<br />
                    There is no need to pass a vertex again, because the shortest path to all other vertices could be found without the need
                    for a second visit for any vertices.   </p>
                <p><strong>Algorithm Steps:</strong> </p>
                <ul>
                    <li>The outer loop traverses from $$0$$ : $$n - 1$$.  </li>
                    <li>Loop over all edges, check if the next node distance &gt; current node distance + edge weight, in this case update the next node distance to "current node distance + edge weight".  </li>
                </ul>
                <p>This algorithm depends on the relaxation principle where the shortest distance for all vertices is gradually replaced by more accurate values until eventually reaching the optimum solution. In the beginning all vertices have a distance of "Infinity", but only the distance of the source vertex = $$0$$, then update all the connected vertices with the new distances (source vertex distance + edge weights), then apply the same concept for the new vertices with new distances and so on.  </p>
                <p><strong>Implementation:</strong> </p>
                <p>Assume the source node has a number ($$0$$):   </p>
                <pre class="prettyprint"><code>    vector &lt;int&gt; v [2000 + 10];
    int dis [1000 + 10];

    for(int i = 0; i &lt; m + 2; i++){

        v[i].clear();
        dis[i] = 2e9;
    }

   for(int i = 0; i &lt; m; i++){

        scanf("%d%d%d", &amp;from , &amp;next , &amp;weight);

        v[i].push_back(from);
        v[i].push_back(next);
        v[i].push_back(weight);
   }

    dis[0] = 0;
    for(int i = 0; i &lt; n - 1; i++){
        int j = 0;
        while(v[j].size() != 0){

            if(dis[ v[j][0]  ] + v[j][2] &lt; dis[ v[j][1] ] ){
                dis[ v[j][1] ] = dis[ v[j][0]  ] + v[j][2];
            }
            j++;
        }
    }
</code></pre>
                <p>A very important application of Bellman Ford is to check if there is a negative cycle in the graph,  </p>
                <p>Time Complexity of Bellman Ford algorithm is relatively high $$O(V \cdot E)$$, in case $$E = V ^ 2$$, $$O(V ^ 3)$$.<br />
            </div>
            <div id="sources" class="tab-pane fade space-div">
                <p>

                </p>
                <ul>
                    <!-- Bellman Ford: -->
<li><a href="https://www.youtube.com/watch?v=FtN3BYH2Zes">bellman ford 1</a></li>
<li><a href="https://www.youtube.com/watch?v=KudAWAMiQog">bellman ford 2</a></li>
<li><a href="https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/">bellman ford 3</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">bellman ford 4</a></li>
                </ul>
            </div>
        </div>
    </div>


    <div class="psuedo-div space-div row" >
        <h2>Code : </h2>

        <p>
            Let's see how to add a node to the linked list:
        <pre><div class="code">def insertAtbegning(self,value):
            newNode = Node(value)
            if self.firstNode != None:
            newNode.link = self.firstNode
            self.firstNode = newNode
            else:
            self.firstNode = newNode
                </div>
            </pre>
        </p>

    </div>

    <div class="time-div space-div row">
        <h2>Time Complexity : </h2>
        <pre>    Average:
                Access,Search : O(n)
                Insertion,Deletion : O(1)

            Worst:
                Access,Search : O(n)
                Insertion,Deletion : O(1)
            </pre>
    </div>

</div>


{% endblock %}